<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>הלימוד היומי</title>
  <style>
    body {
      font-family: "Alef", sans-serif;
      background: linear-gradient(to bottom, #e3f2fd, #90caf9);
      color: #333;
      margin: 0;
      padding: 20px;
      direction: rtl;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    .box {
      margin: 20px auto;
      max-width: 800px;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    h2 {
      margin-top: 0;
    }
    #toggleAddBookBtn {
      display: block;
      width: 100%;
      margin: 20px auto;
      padding: 15px;
      border: none;
      border-radius: 5px;
      background: #2ecc71;
      color: #fff;
      font-size: 1.1rem;
      cursor: pointer;
      text-align: center;
    }
    #toggleAddBookBtn:hover {
      background: #27ae60;
    }
    #addBookContainer {
      display: none;
    }
    label {
      display: block;
      margin-bottom: 6px;
      font-weight: bold;
    }
    input, select, button {
      width: 100%;
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ccc;
      font-size: 1rem;
      box-sizing: border-box;
    }
    button {
      background: #4caf50;
      color: #fff;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      transition: background 0.3s;
    }
    button:hover {
      background: #45a049;
    }
    .bookContainer {
      margin-bottom: 20px;
      border-bottom: 1px solid #ccc;
      padding-bottom: 10px;
    }
    .bookTitle {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 1.2rem;
      cursor: pointer;
      color: #2980b9;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .bookTitle:hover {
      text-decoration: underline;
    }
    /* אלמנט עוטף של כל המקטעים (העכשוויים והעבר) */
    .allChunksWrapper {
      display: none; 
      margin: 10px 0;
      padding: 0;
    }
    .singleChunkContainer {
      border-bottom: 1px solid #ddd;
      padding: 10px 0;
    }
    .chunkText {
      margin: 10px 0;
      font-size: 1rem;
      line-height: 1.6;
      white-space: pre-line;
      display: none; /* מוסתר כברירת מחדל */
    }
    .btnRow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 10px;
    }
    .navigationBtn,
    .removeBtn {
      padding: 8px 16px;
      font-size: 0.9rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      color: #fff;
      transition: background 0.3s;
    }
    .navigationBtn {
      background: #3498db;
    }
    .navigationBtn:hover {
      background: #2980b9;
    }
    .removeBtn {
      background: #e74c3c;
    }
    .removeBtn:hover {
      background: #c0392b;
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      font-size: 1.5rem;
      color: #3498db;
    }

    /* צ'קבוקס מעוצב - דוגמה בסיסית */
    .checkboxContainer {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
    }
    .customCheckbox {
      appearance: none;
      width: 20px;
      height: 20px;
      border: 2px solid #3498db;
      border-radius: 4px;
      cursor: pointer;
      position: relative;
      outline: none;
      transition: background 0.2s, border-color 0.2s;
    }
    .customCheckbox:checked {
      background: #3498db;
      border-color: #2980b9;
    }
    .customCheckbox:checked::after {
      content: "✔";
      font-size: 14px;
      color: #fff;
      position: absolute;
      top: -3px;
      left: 3px;
    }

    /* הוספת קו מפריד דק */
    .separator {
      border-bottom: 1px solid #ccc;
      margin: 10px 0;
    }

    @media (max-width: 600px) {
      .box {
        max-width: 90%;
      }
      #toggleAddBookBtn {
        max-width: 90%;
      }
    }
  </style>
</head>
<body>
  <h1>הלימוד היומי</h1>

  <!-- כפתור לפתיחת הטופס להוספת לימוד -->
  <button id="toggleAddBookBtn" onclick="toggleAddBookForm()">
    הוספת לימוד יומי מתוך ספר
  </button>

  <!-- תיבה מוסתרת עם טופס הוספת לימוד -->
  <div id="addBookContainer" class="box">
    <h2>טופס הוספת לימוד יומי</h2>
    <label for="bookName">שם הספר (למשל: מסילת ישרים):</label>
    <input type="text" id="bookName" placeholder="מסילת ישרים" required />

    <label for="wordCount">כמות מילים יומית (לדוגמה: 300):</label>
    <input type="number" id="wordCount" placeholder="300" min="1" required />

    <label for="mode">מצב לימוד:</label>
    <select id="mode">
      <option value="accumulate">חובות מצטברים</option>
      <!-- שינינו כאן במקום block, כתוב: -->
      <option value="noDebts">ללא חובות מצטברים</option>
    </select>

    <button onclick="addBook()">הוסף לימוד</button>
  </div>

  <!-- תיבה להצגת הלימודים הפעילים -->
  <div id="content" class="box">
    <h2>לימודים פעילים</h2>
    <div id="booksContainer">
      <p>לא הוספת לימודים עדיין.</p>
    </div>
  </div>

  <!-- אינדיקטור טעינה -->
  <div id="loadingIndicator" class="loading-overlay" style="display: none;">
    טוען...
  </div>

  <script>
    /*
      מבנה הנתונים במערך books (הרחבה עבור מצב accumulate):
      books = [
        {
          id: מזהה ייחודי (Date.now()),
          name: "מסילת ישרים",
          mode: "accumulate" | "noDebts",  // 'noDebts' = "ללא חובות מצטברים"
          wordCount: 300,
          chapters: [ 
            {
              chapterNumber: 1,
              chapterIdentifier: "פרק א'",
              text: "טקסט הפרק",
              chunks: [
                { 
                  text: "תוכן מקטע", 
                  read: false,
                  dateAssigned: "2025-01-01" // מציין באיזה יום "נחשף" המקטע הזה ללומד
                }, 
                ...
              ],
            },
            ...
          ],
          currentChapterIndex: 0,
          currentChunkIndex: 0,
          latestChapterIndex: 0,
          readChapters: [],
          lastAccessDate: "",
          // סימנייה: המקטע האחרון שממנו ניווטנו
          bookmarkChapterIndex: null,
          bookmarkChunkIndex: null
        }
      ]
    */

    let books = JSON.parse(localStorage.getItem("books")) || [];

    // פונקציה עם ריטריי וטיימאאוט לבקשות API
    async function fetchWithRetry(url, maxRetries = 3, timeout = 5000) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return await response.json();
        } catch (error) {
          if (i === maxRetries - 1) throw error;
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }

    // מטמון לעיבוד טקסט (פיצול למקטעים)
    const textProcessingCache = new Map();

    function processText(text, wordCount) {
      const cacheKey = `${text.slice(0, 100)}_${wordCount}`;
      if (textProcessingCache.has(cacheKey)) {
        return textProcessingCache.get(cacheKey);
      }

      const chunks = splitIntoChunks(text, wordCount);
      textProcessingCache.set(cacheKey, chunks);
      
      // ניקוי המטמון אם גדול מדי
      if (textProcessingCache.size > 100) {
        const firstKey = textProcessingCache.keys().next().value;
        textProcessingCache.delete(firstKey);
      }
      
      return chunks;
    }

    // חלוקת טקסט לקטעים לפי מספר מילים
    function splitIntoChunks(text, wordCount) {
      const paragraphs = text.split(/\n{2,}/).filter(p => p.trim() !== '');
      const chunks = [];
      let currentChunk = "";
      let currentWords = 0;

      for (let para of paragraphs) {
        const pWords = para.split(/\s+/).filter(Boolean).length;
        if (currentWords + pWords <= wordCount) {
          currentChunk += (currentChunk ? "\n\n" : "") + para;
          currentWords += pWords;
        } else {
          if (currentChunk) {
            chunks.push({ text: currentChunk, read: false, dateAssigned: "" });
          }
          currentChunk = para;
          currentWords = pWords;
        }
      }

      if (currentChunk) {
        chunks.push({ text: currentChunk, read: false, dateAssigned: "" });
      }

      return chunks;
    }

    // ולידציה משופרת
    function validateBookInput(bookName, wordCount) {
      const errors = [];
      if (!bookName || bookName.length < 2) {
        errors.push("שם הספר חייב להכיל לפחות 2 תווים.");
      }
      if (!wordCount || wordCount < 50 || wordCount > 1000) {
        errors.push("מספר המילים חייב להיות בין 50 ל-1000.");
      }
      if (/[<>%$]/.test(bookName)) {
        errors.push("שם הספר מכיל תווים לא חוקיים (כמו <, >, %, $).");
      }
      return errors;
    }

    // דיבאונסינג לרינדור
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    const debouncedRenderBooks = debounce(renderBooks, 250);

    // מציג/מסתיר את טופס הוספת לימוד
    function toggleAddBookForm() {
      const container = document.getElementById("addBookContainer");
      if (container.style.display === "none" || container.style.display === "") {
        container.style.display = "block";
      } else {
        container.style.display = "none";
      }
    }

    // פונקציה להראות/להסתיר אינדיקטור טעינה
    function showLoadingIndicator(show) {
      const loadingDiv = document.getElementById('loadingIndicator');
      loadingDiv.style.display = show ? 'flex' : 'none';
    }

    // הגדרת מיפוי ספרים לתחיליות הפרקים שלהם
    const bookMappings = {
      "מסילת ישרים": {
        prefixType: "hebrewLetters",
        prefixWord: "פרק"
      },
      "קיצור שולחן ערוך": {
        prefixType: "hebrewLetters",
        prefixWord: "סימן"
      },
      // ניתן להוסיף ספרים נוספים כאן
    };

    // פונקציה להמרת מספרים לאותיות עבריות
    function numberToHebrew(number) {
      const units = ['', 'א', 'ב', 'ג', 'ד', 'ה', 'ו', 'ז', 'ח', 'ט'];
      const tens = ['', 'י', 'כ', 'ל', 'מ', 'נ', 'ס', 'ע', 'פ', 'צ'];
      if (number === 0) return '';
      let result = '';
      if (number >= 10) {
        let ten = Math.floor(number / 10);
        let unit = number % 10;

        // טיפול במקרים מיוחדים של 15 ו-16
        if (ten === 1 && (unit === 5 || unit === 6)) {
          return (unit === 5) ? 'טו' : 'טז';
        }

        if (ten > 0) {
          result += tens[ten];
        }
        if (unit > 0) {
          result += units[unit];
        }
      } else {
        result += units[number];
      }
      return result;
    }

    // פונקציה לחישוב התחילית של הפרק בהתאם למיפוי הספר
    function determineChapterPrefix(bookName, chapterNumber) {
      if (bookMappings[bookName]) {
        const mapping = bookMappings[bookName];
        if (mapping.prefixType === "hebrewLetters") {
          const hebrewNumber = numberToHebrew(chapterNumber);
          return `${mapping.prefixWord} ${hebrewNumber}`;
        }
      }
      // ברירת מחדל לפרקים מספריים
      return `פרק ${chapterNumber}`;
    }

    // פונקציה לחישוב מזהה הפרק בהתאם לפרופיל הספר
    function getChapterIdentifier(bookName, chapterNumber) {
      return determineChapterPrefix(bookName, chapterNumber);
    }

    // ולידציה של מצב הספר
    function validateBookState(book) {
      if (book.currentChapterIndex == null) book.currentChapterIndex = 0;
      if (book.currentChunkIndex == null) book.currentChunkIndex = 0;
      if (book.latestChapterIndex == null) book.latestChapterIndex = 0;
      if (!book.readChapters) book.readChapters = [];
      if (!book.lastAccessDate) book.lastAccessDate = "";
      if (book.bookmarkChapterIndex == null) book.bookmarkChapterIndex = 0;
      if (book.bookmarkChunkIndex == null) book.bookmarkChunkIndex = 0;

      // וידוא שהאינדקסים בטווח תקין
      if (book.currentChapterIndex >= book.chapters.length) {
        book.currentChapterIndex = book.chapters.length - 1;
      }
      if (book.currentChapterIndex < 0) book.currentChapterIndex = 0;

      const currentChapter = book.chapters[book.currentChapterIndex];
      if (currentChapter) {
        if (book.currentChunkIndex >= currentChapter.chunks.length) {
          book.currentChunkIndex = currentChapter.chunks.length - 1;
        }
        if (book.currentChunkIndex < 0) book.currentChunkIndex = 0;
      }
    }

    // הוספת לימוד חדש
    async function addBook() {
      const bookNameInput = document.getElementById("bookName").value.trim();
      const wordCount = parseInt(document.getElementById("wordCount").value);
      const mode = document.getElementById("mode").value; // "accumulate" / "noDebts"

      // ולידציה
      const validationErrors = validateBookInput(bookNameInput, wordCount);
      if (validationErrors.length > 0) {
        alert(validationErrors.join("\n"));
        return;
      }

      // המרת שם הספר לפורמט שמתאים ל-API של ספריא (החלפת רווחים בקווים תחתונים)
      const apiBookName = bookNameInput.replace(/\s+/g, '_');

      try {
        showLoadingIndicator(true);
        const apiUrl = `https://www.sefaria.org/api/texts/${encodeURIComponent(apiBookName)}?lang=he`;
        const data = await fetchWithRetry(apiUrl);

        // חילוץ הטקסט מהתשובה
        const textArray = data.he;
        if (!textArray || textArray.length === 0) {
          throw new Error("לא אותרו פסקאות או שהטקסט ריק.");
        }

        // הגדרת סעיפים לא רצויים להימנעות מהם
        const unwantedSections = ["הקדמה", "אינדקס", "הערות", "סיכומים", "תודות", "ספרות", "עריכה", "פרקים"];

        // סינון הפסקאות כדי להתחיל מדברי המחבר בלבד
        const processedParagraphs = [];
        let skip = true;
        let currentChapter = getChapterIdentifier(bookNameInput, 1); // התחלת הפרק הראשון

        // הגדרת chapterPrefixes
        const chapterPrefixes = Object.values(bookMappings).flatMap(mapping => mapping.prefixWord);

        for (let para of textArray) {
          if (unwantedSections.some(section => para.startsWith(section))) {
            skip = true;
            continue;
          }
          const chapterMatch = para.match(new RegExp(`^(${chapterPrefixes.join('|')})\\s*[א-ת]+`));
          if (chapterMatch) {
            currentChapter = getChapterIdentifier(bookNameInput, processedParagraphs.length + 1); 
            skip = false;
            continue; 
          }
          if (skip && !unwantedSections.some(section => para.startsWith(section))) {
            skip = false;
          }
          if (!skip) {
            processedParagraphs.push({ text: para, chapter: currentChapter });
          }
        }

        if (processedParagraphs.length === 0) {
          throw new Error("לא אותרו פסקאות או שהטקסט ריק לאחר הסינון.");
        }

        // חלוקה לפרקים
        const chaptersMap = {};
        processedParagraphs.forEach(para => {
          if (!chaptersMap[para.chapter]) {
            chaptersMap[para.chapter] = [];
          }
          chaptersMap[para.chapter].push(para.text);
        });

        const chaptersList = Object.keys(chaptersMap).map((chapterIdentifier, index) => ({
          chapterNumber: index + 1,
          chapterIdentifier: chapterIdentifier,
          text: chaptersMap[chapterIdentifier].join('\n\n'),
          chunks: splitIntoChunks(chaptersMap[chapterIdentifier].join('\n\n'), wordCount)
        }));

        if (chaptersList.length === 0) {
          throw new Error("לא נמצאו פרקים לטעינה.");
        }

        const newBook = {
          id: Date.now(),
          name: apiBookName.replace(/_/g, ' '),
          mode: mode,
          wordCount: wordCount,
          chapters: [chaptersList[0]],
          currentChapterIndex: 0,
          currentChunkIndex: 0,
          latestChapterIndex: 0,
          readChapters: [],
          lastAccessDate: "",
          bookmarkChapterIndex: 0,
          bookmarkChunkIndex: 0
        };

        // במצב accumulate – רק הקטע הראשון של הפרק הראשון יינתן להיום
        const today = new Date().toISOString().split("T")[0];
        if (mode === "accumulate" && newBook.chapters[0].chunks.length > 0) {
          newBook.chapters[0].chunks[0].dateAssigned = today;
        }

        books.push(newBook);
        localStorage.setItem("books", JSON.stringify(books));

        alert(`הלימוד '${newBook.name}' נוסף בהצלחה!`);
        toggleAddBookForm();
        debouncedRenderBooks();
      } catch (err) {
        console.error(err);
        alert("שגיאה בטעינת הטקסט: " + err.message);
      } finally {
        showLoadingIndicator(false);
      }
    }

    // פונקציה לבדיקה יומית (accumulate/noDebts)
    async function dailyCheck() {
      const today = new Date().toISOString().split("T")[0];
      for (let book of books) {
        if (book.lastAccessDate !== today) {
          // אם יש סימנייה – נתקדם אל המקטע הבא שלה
          if (book.bookmarkChapterIndex != null && book.bookmarkChunkIndex != null) {
            // נתקדם +1
            const ch = book.bookmarkChapterIndex;
            const ck = book.bookmarkChunkIndex;
            // אם המקטע הזה קיים, נתקדם למקטע הבא
            if (book.chapters[ch] && book.chapters[ch].chunks[ck+1]) {
              book.currentChapterIndex = ch;
              book.currentChunkIndex = ck+1;
            } else {
              // אם אין מקטע נוסף בפרק – אולי נלך לפרק הבא
              if (ch < book.chapters.length - 1) {
                book.currentChapterIndex = ch+1;
                book.currentChunkIndex = 0;
              }
            }
            // אפס את הסימנייה ליום הבא
            book.bookmarkChapterIndex = 0;
            book.bookmarkChunkIndex = 0;
          }

          if (book.mode === "accumulate") {
            await assignNewChunkForAccumulate(book, today);

            // הסתרת מקטעים מסומנים כנקראו מאתמול
            book.chapters.forEach(chapter => {
              chapter.chunks.forEach(chunk => {
                // אם המקטע מסומן כנקרא ותאריך השיוך שלו פחות מהיום => הוא לא יוצג
                if (chunk.read && chunk.dateAssigned && chunk.dateAssigned < today) {
                  // "מסירים" את dateAssigned כדי שלא יוצג
                  chunk.dateAssigned = null;  
                }
              });
            });
          }
          else if (book.mode === "noDebts") {
            // אם כל המקטעים של הפרק הנוכחי נקראו – נטען פרק חדש או נעבור הלאה
            const currentChapter = book.chapters[book.currentChapterIndex];
            if (currentChapter && currentChapter.chunks.every(c => c.read)) {
              if (book.currentChapterIndex < book.chapters.length - 1) {
                book.currentChapterIndex++;
                book.currentChunkIndex = 0;
              } else {
                const success = await loadNextChapter(book);
                if (success) {
                  book.currentChapterIndex++;
                  book.currentChunkIndex = 0;
                }
              }
            }
          }
          book.lastAccessDate = today;
        }
      }
      localStorage.setItem("books", JSON.stringify(books));
    }

    // מקצה מקטע אחד ביום במצב accumulate
    async function assignNewChunkForAccumulate(book, today) {
      let assigned = false;

      // קודם נבדוק אם יש צורך לטעון פרק חדש
      for (let chIndex = 0; chIndex < book.chapters.length; chIndex++) {
        const chapter = book.chapters[chIndex];
        for (let cIndex = 0; cIndex < chapter.chunks.length; cIndex++) {
          const chunk = chapter.chunks[cIndex];
          if (!chunk.read && !chunk.dateAssigned) {
            chunk.dateAssigned = today;
            assigned = true;
            break;
          }
        }
        if (assigned) break;
      }

      if (!assigned) {
        // נטען פרק חדש
        const success = await loadNextChapter(book);
        if (success) {
          const newChapter = book.chapters[book.chapters.length - 1];
          if (newChapter && newChapter.chunks.length > 0) {
            newChapter.chunks[0].dateAssigned = today;
          }
        }
      }
    }

    // טעינת פרק הבא מה-API
    async function loadNextChapter(book) {
      const nextChapterNumber = book.chapters.length + 1;
      const nextChapterIdentifier = getChapterIdentifier(book.name, nextChapterNumber);

      const apiBookName = book.name.replace(/\s+/g, '_');
      const apiUrl = `https://www.sefaria.org/api/texts/${encodeURIComponent(apiBookName)}.${encodeURIComponent(nextChapterIdentifier)}?lang=he`;

      try {
        showLoadingIndicator(true);
        const data = await fetchWithRetry(apiUrl);
        const textArray = data.he;
        if (!textArray || textArray.length === 0) {
          alert(`לא ניתן לטעון את ${nextChapterIdentifier}. ייתכן שזה סוף הספר.`);
          return false; 
        }

        const unwantedSections = ["הקדמה", "אינדקס", "הערות", "סיכומים", "תודות", "ספרות", "עריכה", "פרקים"];
        const processedParagraphs = [];
        let skip = true;
        let currentChapter = nextChapterIdentifier;

        const chapterPrefixes = Object.values(bookMappings).flatMap(mapping => mapping.prefixWord);

        for (let para of textArray) {
          if (unwantedSections.some(section => para.startsWith(section))) {
            skip = true;
            continue;
          }
          const chapterMatch = para.match(new RegExp(`^(${chapterPrefixes.join('|')})\\s*[א-ת]+`));
          if (chapterMatch) {
            currentChapter = getChapterIdentifier(book.name, nextChapterNumber);
            skip = false;
            continue;
          }
          if (skip && !unwantedSections.some(section => para.startsWith(section))) {
            skip = false;
          }
          if (!skip) {
            processedParagraphs.push({ text: para, chapter: currentChapter });
          }
        }

        if (processedParagraphs.length === 0) {
          throw new Error(`לא אותרו פסקאות או שהטקסט ריק לאחר הסינון בפרק ${nextChapterIdentifier}.`);
        }

        const chaptersMap = {};
        processedParagraphs.forEach(para => {
          if (!chaptersMap[para.chapter]) {
            chaptersMap[para.chapter] = [];
          }
          chaptersMap[para.chapter].push(para.text);
        });

        const chaptersList = Object.keys(chaptersMap).map((chapterIdentifier, index) => ({
          chapterNumber: nextChapterNumber + index,
          chapterIdentifier: chapterIdentifier,
          text: chaptersMap[chapterIdentifier].join('\n\n'),
          chunks: splitIntoChunks(chaptersMap[chapterIdentifier].join('\n\n'), book.wordCount)
        }));

        if (chaptersList.length === 0) {
          throw new Error(`לא נמצאו פרקים לטעינה בפרק ${nextChapterIdentifier}.`);
        }

        book.chapters.push({
          chapterNumber: chaptersList[0].chapterNumber,
          chapterIdentifier: chaptersList[0].chapterIdentifier,
          text: chaptersList[0].text,
          chunks: chaptersList[0].chunks
        });

        if (book.mode === "accumulate") {
          book.latestChapterIndex = book.chapters.length - 1;
        }

        localStorage.setItem("books", JSON.stringify(books));
        return true; 
      } catch (err) {
        console.error(err);
        alert(`שגיאה בטעינת הפרק הבא: ${err.message}`);
        return false;
      } finally {
        showLoadingIndicator(false);
      }
    }

    // פונקציית סימון מקטע כנקרא/לא-נקרא
    function toggleChunkRead(bookId, chapterIndex, chunkIndex) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;

      const chapter = book.chapters[chapterIndex];
      if (!chapter) return;

      chapter.chunks[chunkIndex].read = !chapter.chunks[chunkIndex].read;
      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // שמים סימנייה (Bookmark) על המקטע הנוכחי (כדי שמחר נתחיל מהבא אחריו)
    function setBookmark(book) {
      book.bookmarkChapterIndex = book.currentChapterIndex;
      book.bookmarkChunkIndex = book.currentChunkIndex;
    }

    // פונקציות ניווט
    async function goToNextDay(bookId) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;

      // אם במצב accumulate – אנו מסמנים את כל החובות הקודמים כנקראו (לפי הבקשה)
      if (book.mode === "accumulate") {
        markAllOldChunksAsRead(book);
      }

      const currentChapter = book.chapters[book.currentChapterIndex];
      if (!currentChapter) return;

      // קודם נשמור סימנייה (bookmark) על הקטע הנוכחי
      setBookmark(book);

      // אם יש עוד מקטעים באותו פרק
      if (book.currentChunkIndex < currentChapter.chunks.length - 1) {
        book.currentChunkIndex++;
      } 
      else if (book.currentChapterIndex < book.chapters.length - 1) {
        // עוברים לפרק הבא אם יש
        book.currentChapterIndex++;
        book.currentChunkIndex = 0;
      } else {
        // מנסים לטעון פרק חדש
        const success = await loadNextChapter(book);
        if (success) {
          book.currentChapterIndex++;
          book.currentChunkIndex = 0;
        }
      }

      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    function goToPrevDay(bookId) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;

      // גם בהקודם, נשמור סימנייה
      setBookmark(book);

      // מצב accumulate – נסמן חובות כנקראו
      if (book.mode === "accumulate") {
        markAllOldChunksAsRead(book);
      }

      if (book.currentChapterIndex < 0) book.currentChapterIndex = 0;
      const currentChapter = book.chapters[book.currentChapterIndex];
      if (!currentChapter) return;

      if (book.currentChunkIndex > 0) {
        book.currentChunkIndex--;
      } else if (book.currentChapterIndex > 0) {
        book.currentChapterIndex--;
        const prevChapter = book.chapters[book.currentChapterIndex];
        if (prevChapter) {
          book.currentChunkIndex = prevChapter.chunks.length - 1;
        }
      }

      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // במצב accumulate: "אם ניווטתי הקודם/הבא – מחק את כל החובות שטרם נקראו"
    function markAllOldChunksAsRead(book) {
      const today = new Date().toISOString().split("T")[0];
      // חובות = מקטעים שלא סומנו, ויש להם dateAssigned < היום
      book.chapters.forEach(chapter => {
        chapter.chunks.forEach(chunk => {
          if (!chunk.read && chunk.dateAssigned && chunk.dateAssigned < today) {
            chunk.read = true;
          }
        });
      });
    }

    // הצגת לימודים פעילים
    function renderBooks() {
      const container = document.getElementById("booksContainer");
      container.innerHTML = "";

      if (books.length === 0) {
        container.innerHTML = "<p>לא הוספת לימודים עדיין.</p>";
        return;
      }

      const today = new Date().toISOString().split("T")[0];

      books.forEach(book => {
        validateBookState(book);

        const bookDiv = document.createElement("div");
        bookDiv.className = "bookContainer";

        // כותרת ראשית
        const titleDiv = document.createElement("div");
        titleDiv.className = "bookTitle";

        if (book.mode === "noDebts") {
          // (לשעבר block)
          const currentChapter = book.chapters[book.currentChapterIndex];
          const currentChunk = currentChapter ? currentChapter.chunks[book.currentChunkIndex] : null;
          if (!currentChapter || !currentChunk) {
            titleDiv.textContent = `${book.name} - (אין מקטעים זמינים)`;
          } else {
            titleDiv.textContent = `${book.name} - ${currentChapter.chapterIdentifier} קטע ${book.currentChunkIndex + 1} מתוך ${currentChapter.chunks.length}`;
          }
        } else {
          // accumulate
          let todayChunk = null;
          let todayChapterIndex = -1;
          let todayChunkIndex = -1;

          for (let chIndex = 0; chIndex < book.chapters.length; chIndex++) {
            const chapter = book.chapters[chIndex];
            for (let cIndex = 0; cIndex < chapter.chunks.length; cIndex++) {
              const chunk = chapter.chunks[cIndex];
              // אם המקטע מוקצה להיום ולא נקרא
              if (chunk.dateAssigned === today && !chunk.read) {
                todayChunk = chunk;
                todayChapterIndex = chIndex;
                todayChunkIndex = cIndex;
                break;
              }
            }
            if (todayChunk) break;
          }

          if (todayChunk) {
            titleDiv.textContent = `${book.name} - ${book.chapters[todayChapterIndex].chapterIdentifier} קטע ${todayChunkIndex + 1} מתוך ${book.chapters[todayChapterIndex].chunks.length}`;
          } else {
            // אם אין מקטע היום, נסתכל על המקטע האחרון שלא נקרא
            const assignedChunks = [];
            book.chapters.forEach((chapter, chIndex) => {
              chapter.chunks.forEach((chunk, cIndex) => {
                if (chunk.dateAssigned && chunk.dateAssigned <= today) {
                  // גם אם chunk.read == true, נראה אותו היום עד תום
                  assignedChunks.push({ chIndex, cIndex, chunk });
                }
              });
            });

            // מסננים כאלו עם dateAssigned null
            const filtered = assignedChunks.filter(item => item.chunk.dateAssigned !== null);

            if (filtered.length > 0) {
              // עכשיו נמיין לפי dateAssigned מהישן לחדש
              filtered.sort((a, b) => {
                if (a.chunk.dateAssigned === b.chunk.dateAssigned) {
                  // אם אותו תאריך, נשאר לפי סדר
                  return 0;
                }
                return (a.chunk.dateAssigned > b.chunk.dateAssigned ? 1 : -1);
              });
              // ניקח את האחרון (הכי "חדש")
              const lastAssigned = filtered[filtered.length - 1];
              titleDiv.textContent = `${book.name} - ${book.chapters[lastAssigned.chIndex].chapterIdentifier} קטע ${lastAssigned.cIndex + 1} מתוך ${book.chapters[lastAssigned.chIndex].chunks.length}`;
            } else {
              titleDiv.textContent = `${book.name} - אין מקטע חדש ליום זה`;
            }
          }
        }

        // בלחיצה על הכותרת – נפתח/נסגור את רשימת כל המקטעים
        titleDiv.onclick = () => toggleAllChunksDisplay(book.id);
        bookDiv.appendChild(titleDiv);

        // אלמנט עוטף לכל המקטעים
        const allChunksWrapper = document.createElement("div");
        allChunksWrapper.className = "allChunksWrapper";
        allChunksWrapper.id = `allChunks-${book.id}`;
        bookDiv.appendChild(allChunksWrapper);

        // צוברים את המקטעים
        let chunksToRender = [];
        if (book.mode === "noDebts") {
          // רק המקטע הנוכחי
          const currentChapter = book.chapters[book.currentChapterIndex];
          if (currentChapter) {
            const currentChunk = currentChapter.chunks[book.currentChunkIndex];
            if (currentChunk) {
              chunksToRender.push({
                chapterIndex: book.currentChapterIndex,
                chunkIndex: book.currentChunkIndex,
                chunk: currentChunk,
                chapterIdentifier: currentChapter.chapterIdentifier
              });

              // מציג את הקטע אוטומטית
              setTimeout(() => {
                const chunkElement = document.getElementById(`chunk-${book.id}-${book.currentChapterIndex}-${book.currentChunkIndex}`);
                if (chunkElement) {
                  chunkElement.style.display = "block";
                }
              }, 0);
            }
          }
        } else {
          // accumulate – נציג את כל המקטעים של היום ושל הימים הקודמים שלא עברו, לפי הסדר מהישן לחדש
          for (let chIndex = 0; chIndex < book.chapters.length; chIndex++) {
            const chapter = book.chapters[chIndex];
            for (let cIndex = 0; cIndex < chapter.chunks.length; cIndex++) {
              const chunk = chapter.chunks[cIndex];
              // נציג מקטע אם dateAssigned != null (כלומר, לא "נמחק") 
              // ותאריך השיוך קטן או שווה להיום
              if (chunk.dateAssigned && chunk.dateAssigned <= today) {
                // אפילו אם chunk.read = true, מציגים אותו עד תום היום
                chunksToRender.push({
                  chapterIndex: chIndex,
                  chunkIndex: cIndex,
                  chunk: chunk,
                  chapterIdentifier: chapter.chapterIdentifier
                });
              }
            }
          }
          // מיון מהישן לחדש
          chunksToRender.sort((a, b) => {
            if (a.chunk.dateAssigned === b.chunk.dateAssigned) {
              return 0;
            }
            return a.chunk.dateAssigned > b.chunk.dateAssigned ? 1 : -1;
          });
        }

        // מייצרים DOM לכל מקטע
        chunksToRender.forEach(item => {
          const { chapterIndex, chunkIndex, chunk, chapterIdentifier } = item;

          const singleChunkDiv = document.createElement("div");
          singleChunkDiv.className = "singleChunkContainer";

          // כותרת משנה
          const subTitle = document.createElement("div");
          subTitle.textContent = `${chapterIdentifier}`;
          singleChunkDiv.appendChild(subTitle);

          // טקסט המקטע (נפתח/נסגר)
          const chunkP = document.createElement("p");
          chunkP.className = "chunkText";
          chunkP.id = `chunk-${book.id}-${chapterIndex}-${chunkIndex}`;
          chunkP.textContent = chunk.text;

          // במצב accumulate – אם זה של היום, נפתח אוטומטית
          if (book.mode === "accumulate" && chunk.dateAssigned === today) {
            chunkP.style.display = "block";
          }

          singleChunkDiv.appendChild(chunkP);

          // צ'קבוקס "סמן כנלמד"
          const checkboxContainer = document.createElement("div");
          checkboxContainer.className = "checkboxContainer";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "customCheckbox";
          checkbox.checked = chunk.read;
          checkbox.onchange = () => toggleChunkRead(book.id, chapterIndex, chunkIndex);

          const label = document.createElement("label");
          label.textContent = "סמן כנלמד";

          checkboxContainer.appendChild(checkbox);
          checkboxContainer.appendChild(label);

          singleChunkDiv.appendChild(checkboxContainer);

          // קו מפריד
          const separator = document.createElement("div");
          separator.className = "separator";
          singleChunkDiv.appendChild(separator);

          allChunksWrapper.appendChild(singleChunkDiv);
        });

        // גם במצב accumulate נוסיף כפתורי ניווט
        const btnRow = document.createElement("div");
        btnRow.className = "btnRow";

        const prevBtn = document.createElement("button");
        prevBtn.className = "navigationBtn";
        prevBtn.textContent = "הקודם";
        prevBtn.onclick = () => goToPrevDay(book.id);
        btnRow.appendChild(prevBtn);

        const nextBtn = document.createElement("button");
        nextBtn.className = "navigationBtn";
        nextBtn.textContent = "הבא";
        nextBtn.onclick = () => goToNextDay(book.id);
        btnRow.appendChild(nextBtn);

        allChunksWrapper.appendChild(btnRow);

        // כפתור הסרה
        const removeRow = document.createElement("div");
        removeRow.className = "btnRow";
        const removeBtn = document.createElement("button");
        removeBtn.className = "removeBtn";
        removeBtn.textContent = "הסר לימוד זה";
        removeBtn.onclick = () => removeBook(book.id);
        removeRow.appendChild(removeBtn);

        allChunksWrapper.appendChild(removeRow);

        container.appendChild(bookDiv);
      });
    }

    // הצגה/הסתרה של כל המקטעים בספר
    function toggleAllChunksDisplay(bookId) {
      const allChunksWrapper = document.getElementById(`allChunks-${bookId}`);
      if (!allChunksWrapper) return;
      if (allChunksWrapper.style.display === "none" || allChunksWrapper.style.display === "") {
        allChunksWrapper.style.display = "block";
      } else {
        allChunksWrapper.style.display = "none";
      }
    }

    // פונקציה להסרת לימוד
    function removeBook(bookId) {
      if (!confirm("האם אתה בטוח שברצונך להסיר את הלימוד הזה?")) return;
      books = books.filter(b => b.id !== bookId);
      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // חישוב סטטיסטיקות למשתמש (לא שינינו כלום כאן)
    function calculateStatistics(bookId) {
      const book = books.find(b => b.id === bookId);
      if (!book) return null;
      
      const totalChunks = book.chapters.reduce((sum, chapter) => 
        sum + chapter.chunks.length, 0);
      
      const readChunks = book.chapters.reduce((sum, chapter) => 
        sum + chapter.chunks.filter(chunk => chunk.read).length, 0);
      
      return {
        progress: Math.round((readChunks / totalChunks) * 100),
        daysActive: book.readChapters.length,
        averageWordsPerDay: book.readChapters.length > 0 ? Math.round((readChunks * book.wordCount) / book.readChapters.length) : 0,
        estimatedCompletion: Math.ceil((totalChunks - readChunks) * book.wordCount / book.wordCount)
      };
    }

    // קיצורי מקלדת
    function setupKeyboardShortcuts() {
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT') return;
        
        switch(e.key) {
          case 'ArrowRight':
            if (e.ctrlKey) {
              const bookId = getCurrentBookId();
              if (bookId) goToNextDay(bookId);
            }
            break;
          case 'ArrowLeft':
            if (e.ctrlKey) {
              const bookId = getCurrentBookId();
              if (bookId) goToPrevDay(bookId);
            }
            break;
          case 'm':
            if (e.ctrlKey) {
              const bookId = getCurrentBookId();
              if (bookId) markCurrentChunkAsRead(bookId);
            }
            break;
        }
      });
    }

    // פונקציה לקבלת מזהה הספר הנוכחי (לדוגמה, הספר הראשון)
    function getCurrentBookId() {
      if (books.length > 0) return books[0].id;
      return null;
    }

    // סימון הקטע הנוכחי כנקרא דרך קיצור מקלדת
    function markCurrentChunkAsRead(bookId) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;
      markChunkAsRead(bookId, book.currentChapterIndex, book.currentChunkIndex);
    }

    // פונקציה לסמן מקטע כנקרא (כפי שהיה)
    function markChunkAsRead(bookId, chapterIndex, chunkIndex) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;

      const chapter = book.chapters[chapterIndex];
      if (!chapter) return;

      chapter.chunks[chunkIndex].read = true;
      if (!book.readChapters.includes(chapterIndex)) {
        book.readChapters.push(chapterIndex);
      }

      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // תמיכה בסוואייפ מובייל
    function setupMobileSwipeSupport() {
      let touchstartX = 0;
      let touchendX = 0;
      
      document.addEventListener('touchstart', e => {
        touchstartX = e.changedTouches[0].screenX;
      });
      
      document.addEventListener('touchend', e => {
        touchendX = e.changedTouches[0].screenX;
        handleSwipe();
      });
      
      function handleSwipe() {
        const diff = touchendX - touchstartX;
        if (Math.abs(diff) < 50) return;
        
        const bookId = getCurrentBookId();
        if (!bookId) return;
        
        const book = books.find(b => b.id === bookId);
        if (!book) return;

        if (diff > 0) {
          goToPrevDay(bookId);
        } else {
          goToNextDay(bookId);
        }
      }
    }

    // בעת טעינת הדף
    window.onload = async function() {
      books.forEach(validateBookState);
      await dailyCheck();      // בדיקת יום חדש (accumulate/noDebts)
      renderBooks();           // הצגת כל הספרים
      setupKeyboardShortcuts();
      setupMobileSwipeSupport();
    };
  </script>
</body>
  </html>
